- 简历上项目书写的几个问题
1. 使用防抖、节流、图片/路由懒加载对项目进行优化；
    - 演示卡顿现象；TypeNav.vue 三级联动组件那里
        - 演示：鼠标进入过快，但是只有3个触发了鼠标进入事件；**用户操作过快，浏览器没来得及反应**；
            - 正常情况：用户慢慢的操作；鼠标进入每一个一级分类h3，都会触发鼠标进入事件
            - 非正常情况：用户操作很快；本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分h3触发了
            - 就是由于用户行为过快，导致浏览器反应不过来，如果当前回调函数中有一些大量业务，**有可能出现卡顿现象**
        - 正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行(如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿)
        - 防抖；**前面所有的触发都被取消**，**最后一次**执行在规定的时间之后触发，也就是说**如果连续快速的触发，只会执行一次**
        - **使用场景**
            - **搜索框**
                - 用户输入完毕，再发送请求
            - 使用lodash.js; 里面封装了 函数的防抖与节流的业务【闭包 + 延时器】
                - 传入需要防抖的函数以及延迟的时间
                - input.oninput = _.debounce(function(){}, delay)
                - 用户输入完毕后执行一次
        - 节流；**在规定的间隔时间范围内不会重复触发回调**，只有大于这个时间间隔才会触发回调，**把频繁回调变为少量触发**
            - 使用场景
                - 点击按钮，计数器的值+1
                - 需求：在1s内，数字只能加1
                - 轮播图；
                    - 慢慢点，图片可以慢慢切换，但是快速点击，图片乱七八糟
            - 也是使用节流函数 lodash.js 【闭包 + 延时器】
                - 也是通过传入节流的函数以及延迟的时间
                - button.onclick = _.throttle(function(){}, delay)
                - 关键问题：不要使用箭头函数，防止出现上下文问题
        - 区别
            - 防抖：用户操作很频繁，但是只执行一次
            - 节流：用户操作很频繁，但是把频繁的操作变为少量的操作【可以给浏览器有充裕的时间来解析代码】

    - 三级联动节流
        - 将频繁的操作变为少量的操作【防止出现卡顿】
        - ES6的写法，函数就是函数；changeIndex(index) {}
        - ES5的写法，使用key: value的形式来进行书写操作
            - changeIndex: _.throttle(function(index){})
        - 三级联动，点击那个跳转到哪个的逻辑就是控制当前的currentIndex
        - 这一点很重要也很关键

    - 图片懒加载
        - 在服务器的数据没回来之前有默认文件【尤其是图片】
        - 插件：vue-lazyload
            - npm i vue-lazyload
            - 引入插件：import VueLazyload from 'vue-lazyload'
            - 注册插件：Vue.use(VueLazyload, {})
            ```
            Vue.use(VueLazyload, {
                <!-- 懒加载默认的图片 -->
                loading: atm
            })
            ```
            - 注册以后，我们想办法在某个地方使用这个插件
                - views => Search => index.vue
                - 分页器上方
                - 在使用图片的时候，使用v-lazy标签
                    - <img v-lazy="good.default" />
        - 自定义插件
            - plugins => myPlugins
            - 插件对外暴露的是一个对象
            - 开发插件
                - Vue.js应该暴露一个install方法，
                - 参数一：Vue构造器；参数二：一个可选的选项对象
                - Vue的插件一定暴露一个对象
                    - let myPlugins = {}
                    - myPlugins.install = function() {}
    - 路由懒加载
        - 当打包构建应用时，JS包会变得非常大，影响页面加载。**如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件**，这样就更高效了；**即访问该组件的时候才对其进行加载，不访问不加载**
        - 使用
            - 定义一个能够被Webpack自动代码分割的异步组件
                - const Foo = () => import('./Foo.vue')
            - 在路由的配置中什么都不需要改变，只需要像往常一样使用Foo
                - const router = new VueRouter({
                    routes: [{path:'/foo', component: Foo}]
                })
            - 和以往引入路由的写法不同

2. 手写分页器实现数据分页功能；
    - views => Search => index.vue
    - 在排序那一块,排序操作中的flag
        - flag: 用户每一次点击li标签的时候，用于区分是综合1；还是价格2
    - 先获取order初始的状态，【咱们需要通过**初始状态**去判断接下来做什么】
        - let orginOrder = this.searchParams.order
        - let orginsFlag = orginOrder.split(':')[0] // 1
        - let orginsFlag = orginOrder.split(':')[1] // desc
    - 初始状态；判断点击是不是综合
    
    - 分页器；
        - 注册为全局组件；因为很多别的组件都需要用到分页器这一块

    - 分页功能分析【手写；了解原理】
        - 分页器展示【你需要知道哪些数据(条件)】
            - 需要知道当前是第几个：pageNo字段代表当前页数
            - 需要知道每一个需要展示多少条数据：pageSize字段
            - 整个分页器一共有多少条数据：total字段进行代表
                - 获取另外一条信息【一共有多少页】
                - 向上取整
            - 分页器连续的页码数：5 ｜ 7【奇数】
                - 因为奇数是对称的
            - 总结
                - 对于分页器而言，自定义前提需要知道4个前提条件
                    - pageNo:当前第几页
                    - pageSize:每一页展示多少条数据
                    - total:代表整个分页一共需要展示多少条数据
                    - continues:代表分页连续页码个数
    - 分页器起始与结束数字计算
        - 测试阶段；先传入一些假数据；【父组件传过来的】
            - 共多少条；直接填入即可
            - 总页数【向上取整】
    - 自定义分页器：在开发的时候先自己传递假的数据进行测试，调试成功后在用服务器数据；
    - 对于分页器而言，很重要的一个地方即为：
        - 在computed中进行计算操作
            - totalPage
            - startNumAndEndNum
        - 算出：**连续页面起始数字和结束数字**【连续的页码数至少是5】
            - 当前页永远在中间
                - 6 7 8 9 10
                - 13 14 15 16 17
            - 有些不正常现象
                - 连续的页码数字是5；【就是至少5页】；如果出现不正常的现象【就是不够5页】
                - 即；连续页码数 > 总页数
            - 正常现象
                - 当前第8页，连续页码数是5
                    - 6 7 8 9 10
                - 当前第8页，连续的页码数是7
                    - 5 6 7 8 9 10 11
                - start = pageNo - parseInt(continues / 2)
                - end = pageNo + parseInt(continues / 2)
                - 下方注意的点
                    - 把出现的不正常现象【start = 0 ｜ 负数】 纠正
                    - if(start < 1) {start = 1; end = continues} 
                    - 把出现的不正常现象【end数字大于总页码数】 纠正
                    - if(end > totalPage){end = totalPage - continues + 1}
            - 注意：
                - 前提：分页器数字没有0；当然也没有负数
                - 当前是第1页；1 2 3 4 5
                - 当前是第2页；1 2 3 4 5 
                - start 和 end 都可能出现问题

                - end出现问题
                    - 加入当前页31
                        - 29 30 31 32 33 => 转换为 27 28 29 30 31
                    - 加入当前页30
                        - 27 28 29 30 31 => 27 28 29 30 31 
            - 分页器展示【分为 上 ｜ 中 ｜ 下 三部分】
                - v-for；数组 ｜ 数字 ｜ 字符串 ｜ 对象
                - 中间结构；需要进行遍历操作；
                    - v-for可能遍历的东西更广，但是有某些内容不展示；通过v-if来判断是否进行展示
                    - 中间结构需要展示出来；需要有自己的判断条件；
                        - 起始数字是否需要；
                        - 通过判断v-if判断第一个数字是否有；
                        - 第2个... 判断是否要不要；
                            - start > 2的时候才判断要不要
                        - 判断最后的按钮要不要也是很关键的
                        - 判断后面的...要不要
    - 上面都是测试的数据；父组件应该动态传入组件；
        - :pageNo; 默认是第一页
        - :pageSize;
    - 点击上一页或者下一页的时候，都需要通知父亲，重新获取数据展示；使用自定义事件来进行操作即可
        - 在父组件设置回调；子组件进行触发
            - 父; <Pagination @getPageNp="getPageNo" /> 
                - 在method中书写回调
                    - 整理带给服务器的参数
                        - this.searchParams.pageNo = pageNo
                        - 再次发送请求即可
            - 子；
                - 第一页的时候是不能点的；下一页这个按钮也要判断是否可以点击
                    - button中通过:disabled来判断
                - 点击上一页的时候，给父组件传递数据
                    - <button @click="$emit('getPageNo', pageNo-1)">
                
                        


            

                
            
   
    
    
3. 购物前台页面的搭建及后台个人中心订单的搭建
