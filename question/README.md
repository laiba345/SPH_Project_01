- 简历上项目书写的几个问题
1. 使用防抖、节流、图片/路由懒加载对项目进行优化；
    - 演示卡顿现象；TypeNav.vue 三级联动组件那里
        - 演示：鼠标进入过快，但是只有3个触发了鼠标进入事件；**用户操作过快，浏览器没来得及反应**；
            - 正常情况：用户慢慢的操作；鼠标进入每一个一级分类h3，都会触发鼠标进入事件
            - 非正常情况：用户操作很快；本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分h3触发了
            - 就是由于用户行为过快，导致浏览器反应不过来，如果当前回调函数中有一些大量业务，**有可能出现卡顿现象**
        - 正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行(如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿)
        - 防抖；**前面所有的触发都被取消**，**最后一次**执行在规定的时间之后触发，也就是说**如果连续快速的触发，只会执行一次**
        - **使用场景**
            - **搜索框**
                - 用户输入完毕，再发送请求
            - 使用lodash.js; 里面封装了 函数的防抖与节流的业务【闭包 + 延时器】
                - 传入需要防抖的函数以及延迟的时间
                - input.oninput = _.debounce(function(){}, delay)
                - 用户输入完毕后执行一次
        - 节流；**在规定的间隔时间范围内不会重复触发回调**，只有大于这个时间间隔才会触发回调，**把频繁回调变为少量触发**
            - 使用场景
                - 点击按钮，计数器的值+1
                - 需求：在1s内，数字只能加1
                - 轮播图；
                    - 慢慢点，图片可以慢慢切换，但是快速点击，图片乱七八糟
            - 也是使用节流函数 lodash.js 【闭包 + 延时器】
                - 也是通过传入节流的函数以及延迟的时间
                - button.onclick = _.throttle(function(){}, delay)
                - 关键问题：不要使用箭头函数，防止出现上下文问题
        - 区别
            - 防抖：用户操作很频繁，但是只执行一次
            - 节流：用户操作很频繁，但是把频繁的操作变为少量的操作【可以给浏览器有充裕的时间来解析代码】

    - 三级联动节流
        - 将频繁的操作变为少量的操作【防止出现卡顿】
        - ES6的写法，函数就是函数；changeIndex(index) {}
        - ES5的写法，使用key: value的形式来进行书写操作
            - changeIndex: _.throttle(function(index){})
        - 三级联动，点击那个跳转到哪个的逻辑就是控制当前的currentIndex
        - 这一点很重要也很关键

    - 图片懒加载
        - 在服务器的数据没回来之前有默认文件【尤其是图片】
        - 插件：vue-lazyload
            - npm i vue-lazyload
            - 引入插件：import VueLazyload from 'vue-lazyload'
            - 注册插件：Vue.use(VueLazyload, {})
            ```
            Vue.use(VueLazyload, {
                <!-- 懒加载默认的图片 -->
                loading: atm
            })
            ```
            - 注册以后，我们想办法在某个地方使用这个插件
                - views => Search => index.vue
                - 分页器上方
                - 在使用图片的时候，使用v-lazy标签
                    - <img v-lazy="good.default" />
        - 自定义插件
            - plugins => myPlugins
            - 插件对外暴露的是一个对象
            - 开发插件
                - Vue.js应该暴露一个install方法，
                - 参数一：Vue构造器；参数二：一个可选的选项对象
                - Vue的插件一定暴露一个对象
                    - let myPlugins = {}
                    - myPlugins.install = function() {}
    - 路由懒加载
        - 当打包构建应用时，JS包会变得非常大，影响页面加载。**如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件**，这样就更高效了；**即访问该组件的时候才对其进行加载，不访问不加载**
        - 使用
            - 定义一个能够被Webpack自动代码分割的异步组件
                - const Foo = () => import('./Foo.vue')
            - 在路由的配置中什么都不需要改变，只需要像往常一样使用Foo
                - const router = new VueRouter({
                    routes: [{path:'/foo', component: Foo}]
                })
            - 和以往引入路由的写法不同

2. 手写分页器实现数据分页功能；
    - views => Search => index.vue
    - 在排序那一块,排序操作中的flag
        - flag: 用户每一次点击li标签的时候，用于区分是综合1；还是价格2
    - 先获取order初始的状态，【咱们需要通过**初始状态**去判断接下来做什么】
        - let orginOrder = this.searchParams.order
        - let orginsFlag = orginOrder.split(':')[0] // 1
        - let orginsFlag = orginOrder.split(':')[1] // desc
    - 初始状态；判断点击是不是综合
    
    - 分页器；
        - 注册为全局组件；因为很多别的组件都需要用到分页器这一块
   
    
    
3. 购物前台页面的搭建及后台个人中心订单的搭建
